
    <!DOCTYPE html>
    <html>
    <head>
        <title>Source Files with Annotations</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                background-color: #f0f0f0;
            }
            details summary {
                padding: 40px;
                padding-left: 120px;
                font-size: 20px;
                background-color: lightblue;
            }
            .code-container {
                background-color: white;
                padding: 20px;
                counter-reset: line;
            }
            pre {
                font-family: 'Courier New', Courier, monospace;
                font-size: 16px;
                position: relative;
                line-height: 4;
            }
            .annotated {
                position: relative;
                display: inline-block;
            }
            .annotation {
                line-height: 1.2;
                position: absolute;
                font-family: Arial, sans-serif;
                font-size: 8px;
                white-space: nowrap;
                text-wrap: auto;
                left: 0;
                max-width: 100%;
                color: green;
                overflow: hidden;
                bottom: 40px;
                max-height: 55px;
            }
            .annotation:hover {
                overflow: visible;
            }
            span.linen::before {
                counter-increment: line;
                content: counter(line);
                position: relative;
                left: -3em;
                width: 2em;
                /* I don't know why this alignment isn't working. */
                text-align: right;
                color: #888;
            }
        }
        </style>
    </head>
    <body>
        
            <details>
            <summary>src/utils/url.ts</summary>
            <div class="code-container">
            <pre>
            
                <span class="line"><span class="linen"></span><span class="annotated">/**</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * @module</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * URL utility.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> */</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export type </span><span class="annotated">Pattern = readonly [string, string,<span class="annotation"><p><code>type Pattern = readonly [string, string, true | RegExp] | "*"</code></p>
<p><em>@module</em> — URL utility.</p></span></span><span class="annotated"> </span><span class="annotated">RegExp | true] | '*'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>interface RegExp</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">splitPath = <span class="annotation"><p><code>const splitPath: (path: string) =&gt; string[]</code></p></span></span><span class="annotated">(</span><span class="annotated">path: string): string[] => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">paths =<span class="annotation"><p><code>const paths: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">path<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">split('/')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.split(separator: string | RegExp, limit?: number): string[] (+1 overload)</code>
Split a string into substrings using the specified separator and return them as an array.</p>
<p><em>@param</em> <code>separator</code> — A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.  </p>
<p><em>@param</em> <code>limit</code> — A value used to limit the number of elements returned in the array.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (</span><span class="annotated">paths[0] === '') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const paths: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    </span><span class="annotated">paths<span class="annotation"><p><code>const paths: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">shift()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) Array&lt;string&gt;.shift(): string | undefined</code>
Removes the first element from an array and returns it.
If the array is empty, undefined is returned and the array is not modified.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">paths&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const paths: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">splitRoutingPath = <span class="annotation"><p><code>const splitRoutingPath: (routePath: string) =&gt; string[]</code></p></span></span><span class="annotated">(</span><span class="annotated">routePath: string): string[] => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) routePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const { </span><span class="annotated">groups,<span class="annotation"><p><code>const groups: [string, string][]</code></p></span></span><span class="annotated"> </span><span class="annotated">path } =<span class="annotation"><p><code>const path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">extractGroupsFromPath<span class="annotation"><p><code>const extractGroupsFromPath: (path: string) =&gt; {
    groups: [string, string][];
    path: string;
}</code></p></span></span><span class="annotated">(</span><span class="annotated">routePath)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) routePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">paths =<span class="annotation"><p><code>const paths: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">splitPath<span class="annotation"><p><code>const splitPath: (path: string) =&gt; string[]</code></p></span></span><span class="annotated">(</span><span class="annotated">path)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">replaceGroupMarks<span class="annotation"><p><code>const replaceGroupMarks: (paths: string[], groups: [string, string][]) =&gt; string[]</code></p></span></span><span class="annotated">(</span><span class="annotated">paths,<span class="annotation"><p><code>const paths: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">groups)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const groups: [string, string][]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">extractGroupsFromPath = <span class="annotation"><p><code>const extractGroupsFromPath: (path: string) =&gt; {
    groups: [string, string][];
    path: string;
}</code></p></span></span><span class="annotated">(</span><span class="annotated">path: string): {<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">groups: [string, string][];<span class="annotation"><p><code>(property) groups: [string, string][]</code></p></span></span><span class="annotated"> </span><span class="annotated">path: string } => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">groups: [string, string][] = []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const groups: [string, string][]</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">path =<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">path<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">replace(/\{[^}]+\}/g, <span class="annotation"><p><code>(method) String.replace(searchValue: {
    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) =&gt; string): string;
}, replacer: (substring: string, ...args: any[]) =&gt; string): string (+3 overloads)</code>
Replaces text in a string, using an object that supports replacement within a string.</p>
<p><em>@param</em> <code>searchValue</code> — A object can search for and replace matches within a string.  </p>
<p><em>@param</em> <code>replacer</code> — A function that returns the replacement text.</p></span></span><span class="annotated">(</span><span class="annotated">match,<span class="annotation"><p><code>(parameter) match: string</code></p></span></span><span class="annotated"> </span><span class="annotated">index) => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) index: any</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    const </span><span class="annotated">mark = `@$<span class="annotation"><p><code>const mark: string</code></p></span></span><span class="annotated">{</span><span class="annotated">index}`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) index: any</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    </span><span class="annotated">groups<span class="annotation"><p><code>const groups: [string, string][]</code></p></span></span><span class="annotated">.</span><span class="annotated">push(<span class="annotation"><p><code>(method) Array&lt;[string, string]&gt;.push(...items: [string, string][]): number</code>
Appends new elements to the end of an array, and returns the new length of the array.</p>
<p><em>@param</em> <code>items</code> — New elements to add to the array.</p></span></span><span class="annotated">[</span><span class="annotated">mark,<span class="annotation"><p><code>const mark: string</code></p></span></span><span class="annotated"> </span><span class="annotated">match])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) match: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return </span><span class="annotated">mark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const mark: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  })</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return { </span><span class="annotated">groups,<span class="annotation"><p><code>(property) groups: [string, string][]</code></p></span></span><span class="annotated"> </span><span class="annotated">path }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">replaceGroupMarks = <span class="annotation"><p><code>const replaceGroupMarks: (paths: string[], groups: [string, string][]) =&gt; string[]</code></p></span></span><span class="annotated">(</span><span class="annotated">paths: string[],<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">groups: [string, string][]): string[] => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) groups: [string, string][]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  for (let </span><span class="annotated">i =<span class="annotation"><p><code>let i: number</code></p></span></span><span class="annotated"> </span><span class="annotated">groups<span class="annotation"><p><code>(parameter) groups: [string, string][]</code></p></span></span><span class="annotated">.</span><span class="annotated">length - 1;<span class="annotation"><p><code>(property) Array&lt;[string, string]&gt;.length: number</code>
Gets or sets the length of the array. This is a number one higher than the highest index in the array.</p></span></span><span class="annotated"> </span><span class="annotated">i >= 0;<span class="annotation"><p><code>let i: number</code></p></span></span><span class="annotated"> </span><span class="annotated">i--) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    const [</span><span class="annotated">mark] =<span class="annotation"><p><code>const mark: string</code></p></span></span><span class="annotated"> </span><span class="annotated">groups<span class="annotation"><p><code>(parameter) groups: [string, string][]</code></p></span></span><span class="annotated">[</span><span class="annotated">i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    for (let </span><span class="annotated">j =<span class="annotation"><p><code>let j: number</code></p></span></span><span class="annotated"> </span><span class="annotated">paths<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">length - 1;<span class="annotation"><p><code>(property) Array&lt;string&gt;.length: number</code>
Gets or sets the length of the array. This is a number one higher than the highest index in the array.</p></span></span><span class="annotated"> </span><span class="annotated">j >= 0;<span class="annotation"><p><code>let j: number</code></p></span></span><span class="annotated"> </span><span class="annotated">j--) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let j: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (</span><span class="annotated">paths<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span><span class="annotated">[</span><span class="annotated">j]<span class="annotation"><p><code>let j: number</code></p></span></span><span class="annotated">.</span><span class="annotated">includes<span class="annotation"><p><code>(method) String.includes(searchString: string, position?: number): boolean</code>
Returns true if searchString appears as a substring of the result of converting this
object to a String, at one or more positions that are
greater than or equal to position; otherwise, returns false.</p>
<p><em>@param</em> <code>searchString</code> — search string  </p>
<p><em>@param</em> <code>position</code> — If position is undefined, 0 is assumed, so as to search all of the String.</p></span></span><span class="annotated">(</span><span class="annotated">mark)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const mark: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">paths<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span><span class="annotated">[</span><span class="annotated">j] =<span class="annotation"><p><code>let j: number</code></p></span></span><span class="annotated"> </span><span class="annotated">paths<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span><span class="annotated">[</span><span class="annotated">j]<span class="annotation"><p><code>let j: number</code></p></span></span><span class="annotated">.</span><span class="annotated">replace<span class="annotation"><p><code>(method) String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)</code>
Replaces text in a string, using a regular expression or search string.</p>
<p><em>@param</em> <code>searchValue</code> — A string or regular expression to search for.  </p>
<p><em>@param</em> <code>replaceValue</code> — A string containing the text to replace. When the <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es5.d.ts#L463%2C13"><code>searchValue</code></a> is a <code>RegExp</code>, all matches are replaced if the <code>g</code> flag is set (or only those matches at the beginning, if the <code>y</code> flag is also present). Otherwise, only the first match of <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es5.d.ts#L463%2C13"><code>searchValue</code></a> is replaced.</p></span></span><span class="annotated">(</span><span class="annotated">mark,<span class="annotation"><p><code>const mark: string</code></p></span></span><span class="annotated"> </span><span class="annotated">groups<span class="annotation"><p><code>(parameter) groups: [string, string][]</code></p></span></span><span class="annotated">[</span><span class="annotated">i][1])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        break</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">paths&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">patternCache: { <span class="annotation"><p><code>const patternCache: {
    [key: string]: Pattern;
}</code></p></span></span><span class="annotated">[</span><span class="annotated">key: string]:<span class="annotation"><p><code>(parameter) key: string</code></p></span></span><span class="annotated"> </span><span class="annotated">Pattern } = {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Pattern = readonly [string, string, true | RegExp] | "*"</code></p>
<p><em>@module</em> — URL utility.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getPattern = <span class="annotation"><p><code>const getPattern: (label: string) =&gt; Pattern | null</code></p></span></span><span class="annotated">(</span><span class="annotated">label: string):<span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated"> </span><span class="annotated">Pattern | null => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Pattern = readonly [string, string, true | RegExp] | "*"</code></p>
<p><em>@module</em> — URL utility.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  // *            => wildcard</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  // :id{[0-9]+}  => ([0-9]+)</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  // :id          => (.+)</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  //const name = ''</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (</span><span class="annotated">label === '*') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) label: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return '*'</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">match =<span class="annotation"><p><code>const match: RegExpMatchArray | null</code></p></span></span><span class="annotated"> </span><span class="annotated">label<span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated">.</span><span class="annotated">match(/^\:([^\{\}]+)(?:\{(.+)\})?$/)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.match(matcher: {
    [Symbol.match](string: string): RegExpMatchArray | null;
}): RegExpMatchArray | null (+1 overload)</code>
Matches a string or an object that supports being matched against, and returns an array
containing the results of that search, or null if no matches are found.</p>
<p><em>@param</em> <code>matcher</code> — An object that supports being matched against.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (</span><span class="annotated">match) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const match: RegExpMatchArray | null</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (!</span><span class="annotated">patternCache<span class="annotation"><p><code>const patternCache: {
    [key: string]: Pattern;
}</code></p></span></span><span class="annotated">[</span><span class="annotated">label]) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) label: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (</span><span class="annotated">match[2]) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const match: RegExpMatchArray</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">patternCache<span class="annotation"><p><code>const patternCache: {
    [key: string]: Pattern;
}</code></p></span></span><span class="annotated">[</span><span class="annotated">label] = <span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated">[</span><span class="annotated">label,<span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated"> </span><span class="annotated">match[1], new<span class="annotation"><p><code>const match: RegExpMatchArray</code></p></span></span><span class="annotated"> </span><span class="annotated">RegExp('^' +<span class="annotation"><p><code>var RegExp: RegExpConstructor
new (pattern: RegExp | string, flags?: string) =&gt; RegExp (+2 overloads)</code></p></span></span><span class="annotated"> </span><span class="annotated">match[2] + '$')]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const match: RegExpMatchArray</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      } else {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">patternCache<span class="annotation"><p><code>const patternCache: {
    [key: string]: Pattern;
}</code></p></span></span><span class="annotated">[</span><span class="annotated">label] = <span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated">[</span><span class="annotated">label,<span class="annotation"><p><code>(parameter) label: string</code></p></span></span><span class="annotated"> </span><span class="annotated">match[1], true]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const match: RegExpMatchArray</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return </span><span class="annotated">patternCache<span class="annotation"><p><code>const patternCache: {
    [key: string]: Pattern;
}</code></p></span></span><span class="annotated">[</span><span class="annotated">label]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) label: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return null</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">/**</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * Try to apply decodeURI() to given string.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * If it fails, skip invalid percent encoding or invalid UTF-8 sequences, and apply decodeURI() to the rest as much as possible.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * @param str The string to decode.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * @returns The decoded string that sometimes contains undecodable percent encoding.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * @example</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * tryDecodeURI('Hello%20World') // 'Hello World'</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> * tryDecodeURI('Hello%20World/%A4%A2') // 'Hello World/%A4%A2'</span></span>
                <span class="line"><span class="linen"></span><span class="annotated"> */</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">tryDecodeURI = <span class="annotation"><p><code>const tryDecodeURI: (str: string) =&gt; string</code>
Try to apply decodeURI() to given string.
If it fails, skip invalid percent encoding or invalid UTF-8 sequences, and apply decodeURI() to the rest as much as possible.</p>
<p><em>@param</em> <code>str</code> — The string to decode.  </p>
<p><em>@returns</em> — The decoded string that sometimes contains undecodable percent encoding.  </p>
<p><em>@example</em><br />
<code>tryDecodeURI('Hello%20World') // 'Hello World'
tryDecodeURI('Hello%20World/%A4%A2') // 'Hello World/%A4%A2'</code></p></span></span><span class="annotated">(</span><span class="annotated">str: string): string => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) str: string</code>
The string to decode.</p>
<p><em>@param</em> <code>str</code> — The string to decode.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  try {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return </span><span class="annotated">decodeURI<span class="annotation"><p><code>function decodeURI(encodedURI: string): string</code>
Gets the unencoded version of an encoded Uniform Resource Identifier (URI).</p>
<p><em>@param</em> <code>encodedURI</code> — A value representing an encoded URI.</p></span></span><span class="annotated">(</span><span class="annotated">str)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) str: string</code>
The string to decode.</p>
<p><em>@param</em> <code>str</code> — The string to decode.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  } catch {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return </span><span class="annotated">str<span class="annotation"><p><code>(parameter) str: string</code>
The string to decode.</p>
<p><em>@param</em> <code>str</code> — The string to decode.</p></span></span><span class="annotated">.</span><span class="annotated">replace(/(?:%[0-9A-Fa-f]{2})+/g, <span class="annotation"><p><code>(method) String.replace(searchValue: {
    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) =&gt; string): string;
}, replacer: (substring: string, ...args: any[]) =&gt; string): string (+3 overloads)</code>
Replaces text in a string, using an object that supports replacement within a string.</p>
<p><em>@param</em> <code>searchValue</code> — A object can search for and replace matches within a string.  </p>
<p><em>@param</em> <code>replacer</code> — A function that returns the replacement text.</p></span></span><span class="annotated">(</span><span class="annotated">match) => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) match: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      try {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        return </span><span class="annotated">decodeURI<span class="annotation"><p><code>function decodeURI(encodedURI: string): string</code>
Gets the unencoded version of an encoded Uniform Resource Identifier (URI).</p>
<p><em>@param</em> <code>encodedURI</code> — A value representing an encoded URI.</p></span></span><span class="annotated">(</span><span class="annotated">match)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) match: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      } catch {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        return </span><span class="annotated">match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) match: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    })</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getPath = <span class="annotation"><p><code>const getPath: (request: Request) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">request:<span class="annotation"><p><code>(parameter) request: Request</code></p></span></span><span class="annotated"> </span><span class="annotated">Request): string => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>interface Request</code>
This Fetch API interface represents a resource request.</p>
<p><a href="https://developer.mozilla.org/docs/Web/API/Request">MDN Reference</a></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">url =<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated"> </span><span class="annotated">request<span class="annotation"><p><code>(parameter) request: Request</code></p></span></span><span class="annotated">.</span><span class="annotated">url&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) Request.url: string</code>
Returns the URL of request as a string.</p>
<p><a href="https://developer.mozilla.org/docs/Web/API/Request/url">MDN Reference</a></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">start =<span class="annotation"><p><code>const start: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('/', 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">i =<span class="annotation"><p><code>let i: number</code></p></span></span><span class="annotated"> </span><span class="annotated">start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const start: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  for (; </span><span class="annotated">i <<span class="annotation"><p><code>let i: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length;<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span><span class="annotated"> </span><span class="annotated">i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    const </span><span class="annotated">charCode =<span class="annotation"><p><code>const charCode: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">charCodeAt<span class="annotation"><p><code>(method) String.charCodeAt(index: number): number</code>
Returns the Unicode value of the character at the specified location.</p>
<p><em>@param</em> <code>index</code> — The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.</p></span></span><span class="annotated">(</span><span class="annotated">i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">charCode === 37) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const charCode: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      // '%'</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      // If the path contains percent encoding, use `indexOf()` to find '?' and return the result immediately.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      // Although this is a performance disadvantage, it is acceptable since we prefer cases that do not include percent encoding.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      const </span><span class="annotated">queryIndex =<span class="annotation"><p><code>const queryIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('?',<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated"> </span><span class="annotated">i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      const </span><span class="annotated">path =<span class="annotation"><p><code>const path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated">(</span><span class="annotated">start,<span class="annotation"><p><code>const start: number</code></p></span></span><span class="annotated"> </span><span class="annotated">queryIndex === -1 ? undefined :<span class="annotation"><p><code>const queryIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">queryIndex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const queryIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      return </span><span class="annotated">tryDecodeURI<span class="annotation"><p><code>const tryDecodeURI: (str: string) =&gt; string</code>
Try to apply decodeURI() to given string.
If it fails, skip invalid percent encoding or invalid UTF-8 sequences, and apply decodeURI() to the rest as much as possible.</p>
<p><em>@param</em> <code>str</code> — The string to decode.  </p>
<p><em>@returns</em> — The decoded string that sometimes contains undecodable percent encoding.  </p>
<p><em>@example</em><br />
<code>tryDecodeURI('Hello%20World') // 'Hello World'
tryDecodeURI('Hello%20World/%A4%A2') // 'Hello World/%A4%A2'</code></p></span></span><span class="annotated">(</span><span class="annotated">path<span class="annotation"><p><code>const path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">includes('%25') ?<span class="annotation"><p><code>(method) String.includes(searchString: string, position?: number): boolean</code>
Returns true if searchString appears as a substring of the result of converting this
object to a String, at one or more positions that are
greater than or equal to position; otherwise, returns false.</p>
<p><em>@param</em> <code>searchString</code> — search string  </p>
<p><em>@param</em> <code>position</code> — If position is undefined, 0 is assumed, so as to search all of the String.</p></span></span><span class="annotated"> </span><span class="annotated">path<span class="annotation"><p><code>const path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">replace(/%25/g, '%2525') :<span class="annotation"><p><code>(method) String.replace(searchValue: {
    [Symbol.replace](string: string, replaceValue: string): string;
}, replaceValue: string): string (+3 overloads)</code>
Passes a string and <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts#L248%2C95"><code>replaceValue</code></a> to the <code>[Symbol.replace]</code> method on <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts#L248%2C13"><code>searchValue</code></a>. This method is expected to implement its own replacement algorithm.</p>
<p><em>@param</em> <code>searchValue</code> — An object that supports searching for and replacing matches within a string.  </p>
<p><em>@param</em> <code>replaceValue</code> — The replacement text.</p></span></span><span class="annotated"> </span><span class="annotated">path)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    } else if (</span><span class="annotated">charCode === 63) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const charCode: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      // '?'</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      break</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">url<span class="annotation"><p><code>const url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated">(</span><span class="annotated">start,<span class="annotation"><p><code>const start: number</code></p></span></span><span class="annotated"> </span><span class="annotated">i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getQueryStrings = <span class="annotation"><p><code>const getQueryStrings: (url: string) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">url: string): string => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">queryIndex =<span class="annotation"><p><code>const queryIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('?', 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">queryIndex === -1 ? '' : '?' +<span class="annotation"><p><code>const queryIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated">(</span><span class="annotated">queryIndex + 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const queryIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getPathNoStrict = <span class="annotation"><p><code>const getPathNoStrict: (request: Request) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">request:<span class="annotation"><p><code>(parameter) request: Request</code></p></span></span><span class="annotated"> </span><span class="annotated">Request): string => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>interface Request</code>
This Fetch API interface represents a resource request.</p>
<p><a href="https://developer.mozilla.org/docs/Web/API/Request">MDN Reference</a></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">result =<span class="annotation"><p><code>const result: string</code></p></span></span><span class="annotated"> </span><span class="annotated">getPath<span class="annotation"><p><code>const getPath: (request: Request) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">request)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) request: Request</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  // if strict routing is false => `/hello/hey/` and `/hello/hey` are treated the same</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">result<span class="annotation"><p><code>const result: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length > 1 &&<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span><span class="annotated"> </span><span class="annotated">result<span class="annotation"><p><code>const result: string</code></p></span></span><span class="annotated">[</span><span class="annotated">result<span class="annotation"><p><code>const result: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length - 1] === '/' ?<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span><span class="annotated"> </span><span class="annotated">result<span class="annotation"><p><code>const result: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice(0, -1) :<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated"> </span><span class="annotated">result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const result: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">mergePath = (..<span class="annotation"><p><code>const mergePath: (...paths: string[]) =&gt; string</code></p></span></span><span class="annotated">.</span><span class="annotated">paths: string[]): string => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">p: string = ''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let p: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">endsWithSlash = false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let endsWithSlash: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  for (let </span><span class="annotated">path of<span class="annotation"><p><code>let path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">paths) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) paths: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    /* ['/hey/','/say'] => ['/hey', '/say'] */</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">p<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">[</span><span class="annotated">p<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length - 1] === '/') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">p =<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated"> </span><span class="annotated">p<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice(0, -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">endsWithSlash = true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let endsWithSlash: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    /* ['/hey','say'] => ['/hey', '/say'] */</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">path[0] !== '/') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">path = `/$<span class="annotation"><p><code>let path: string</code></p></span></span><span class="annotated">{</span><span class="annotated">path}`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    /* ['/hey/', '/'] => `/hey/` */</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">path === '/' &&<span class="annotation"><p><code>let path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">endsWithSlash) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let endsWithSlash: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">p = `$<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">{</span><span class="annotated">p}/`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let p: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    } else if (</span><span class="annotated">path !== '/') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">p = `$<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">{</span><span class="annotated">p}$<span class="annotation"><p><code>let p: string</code></p></span></span><span class="annotated">{</span><span class="annotated">path}`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    /* ['/', '/'] => `/` */</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">path === '/' &&<span class="annotation"><p><code>let path: string</code></p></span></span><span class="annotated"> </span><span class="annotated">p === '') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let p: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">p = '/'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let p: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let p: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">checkOptionalParameter = <span class="annotation"><p><code>const checkOptionalParameter: (path: string) =&gt; string[] | null</code></p></span></span><span class="annotated">(</span><span class="annotated">path: string): string[] | null => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) path: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  /*</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">   If path is `/api/animals/:type?` it will return:</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">   [`/api/animals`, `/api/animals/:type`]</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">   in other cases it will return null</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  */</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (!</span><span class="annotated">path<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">match(/\:.+\?$/)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.match(matcher: {
    [Symbol.match](string: string): RegExpMatchArray | null;
}): RegExpMatchArray | null (+1 overload)</code>
Matches a string or an object that supports being matched against, and returns an array
containing the results of that search, or null if no matches are found.</p>
<p><em>@param</em> <code>matcher</code> — An object that supports being matched against.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return null</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">segments =<span class="annotation"><p><code>const segments: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">path<span class="annotation"><p><code>(parameter) path: string</code></p></span></span><span class="annotated">.</span><span class="annotated">split('/')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.split(separator: string | RegExp, limit?: number): string[] (+1 overload)</code>
Split a string into substrings using the specified separator and return them as an array.</p>
<p><em>@param</em> <code>separator</code> — A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.  </p>
<p><em>@param</em> <code>limit</code> — A value used to limit the number of elements returned in the array.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">results: string[] = []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const results: string[]</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">basePath = ''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let basePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">segments<span class="annotation"><p><code>const segments: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">forEach(<span class="annotation"><p><code>(method) Array&lt;string&gt;.forEach(callbackfn: (value: string, index: number, array: string[]) =&gt; void, thisArg?: any): void</code>
Performs the specified action for each element in an array.</p>
<p><em>@param</em> <code>callbackfn</code> — A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.  </p>
<p><em>@param</em> <code>thisArg</code> — An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.</p></span></span><span class="annotated">(</span><span class="annotated">segment) => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">segment !== '' && !/\:/<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span><span class="annotated">.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">segment)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">basePath += '/' +<span class="annotation"><p><code>let basePath: string</code></p></span></span><span class="annotated"> </span><span class="annotated">segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    } else if (/\:/.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">segment)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (/\?/.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">segment)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        if (</span><span class="annotated">results<span class="annotation"><p><code>const results: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">length === 0 &&<span class="annotation"><p><code>(property) Array&lt;string&gt;.length: number</code>
Gets or sets the length of the array. This is a number one higher than the highest index in the array.</p></span></span><span class="annotated"> </span><span class="annotated">basePath === '') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let basePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">          </span><span class="annotated">results<span class="annotation"><p><code>const results: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">push('/')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) Array&lt;string&gt;.push(...items: string[]): number</code>
Appends new elements to the end of an array, and returns the new length of the array.</p>
<p><em>@param</em> <code>items</code> — New elements to add to the array.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        } else {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">          </span><span class="annotated">results<span class="annotation"><p><code>const results: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">push<span class="annotation"><p><code>(method) Array&lt;string&gt;.push(...items: string[]): number</code>
Appends new elements to the end of an array, and returns the new length of the array.</p>
<p><em>@param</em> <code>items</code> — New elements to add to the array.</p></span></span><span class="annotated">(</span><span class="annotated">basePath)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let basePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        const </span><span class="annotated">optionalSegment =<span class="annotation"><p><code>const optionalSegment: string</code></p></span></span><span class="annotated"> </span><span class="annotated">segment<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span><span class="annotated">.</span><span class="annotated">replace('?', '')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)</code>
Replaces text in a string, using a regular expression or search string.</p>
<p><em>@param</em> <code>searchValue</code> — A string or regular expression to search for.  </p>
<p><em>@param</em> <code>replaceValue</code> — A string containing the text to replace. When the <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es5.d.ts#L463%2C13"><code>searchValue</code></a> is a <code>RegExp</code>, all matches are replaced if the <code>g</code> flag is set (or only those matches at the beginning, if the <code>y</code> flag is also present). Otherwise, only the first match of <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es5.d.ts#L463%2C13"><code>searchValue</code></a> is replaced.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">basePath += '/' +<span class="annotation"><p><code>let basePath: string</code></p></span></span><span class="annotated"> </span><span class="annotated">optionalSegment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const optionalSegment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">results<span class="annotation"><p><code>const results: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">push<span class="annotation"><p><code>(method) Array&lt;string&gt;.push(...items: string[]): number</code>
Appends new elements to the end of an array, and returns the new length of the array.</p>
<p><em>@param</em> <code>items</code> — New elements to add to the array.</p></span></span><span class="annotated">(</span><span class="annotated">basePath)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let basePath: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      } else {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">basePath += '/' +<span class="annotation"><p><code>let basePath: string</code></p></span></span><span class="annotated"> </span><span class="annotated">segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) segment: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  })</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">results<span class="annotation"><p><code>const results: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">filter(<span class="annotation"><p><code>(method) Array&lt;string&gt;.filter(predicate: (value: string, index: number, array: string[]) =&gt; unknown, thisArg?: any): string[] (+1 overload)</code>
Returns the elements of an array that meet the condition specified in a callback function.</p>
<p><em>@param</em> <code>predicate</code> — A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.  </p>
<p><em>@param</em> <code>thisArg</code> — An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.</p></span></span><span class="annotated">(</span><span class="annotated">v,<span class="annotation"><p><code>(parameter) v: string</code></p></span></span><span class="annotated"> </span><span class="annotated">i,<span class="annotation"><p><code>(parameter) i: number</code></p></span></span><span class="annotated"> </span><span class="annotated">a) =><span class="annotation"><p><code>(parameter) a: string[]</code></p></span></span><span class="annotated"> </span><span class="annotated">a<span class="annotation"><p><code>(parameter) a: string[]</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf<span class="annotation"><p><code>(method) Array&lt;string&gt;.indexOf(searchElement: string, fromIndex?: number): number</code>
Returns the index of the first occurrence of a value in an array, or -1 if it is not present.</p>
<p><em>@param</em> <code>searchElement</code> — The value to locate in the array.  </p>
<p><em>@param</em> <code>fromIndex</code> — The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.</p></span></span><span class="annotated">(</span><span class="annotated">v) ===<span class="annotation"><p><code>(parameter) v: string</code></p></span></span><span class="annotated"> </span><span class="annotated">i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) i: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">// Optimized</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">_decodeURI = <span class="annotation"><p><code>const _decodeURI: (value: string) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">value: string) => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (!/[%+]/.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">value)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    return </span><span class="annotated">value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (</span><span class="annotated">value<span class="annotation"><p><code>(parameter) value: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('+') !== -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    </span><span class="annotated">value =<span class="annotation"><p><code>(parameter) value: string</code></p></span></span><span class="annotated"> </span><span class="annotated">value<span class="annotation"><p><code>(parameter) value: string</code></p></span></span><span class="annotated">.</span><span class="annotated">replace(/\+/g, ' ')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.replace(searchValue: {
    [Symbol.replace](string: string, replaceValue: string): string;
}, replaceValue: string): string (+3 overloads)</code>
Passes a string and <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts#L248%2C95"><code>replaceValue</code></a> to the <code>[Symbol.replace]</code> method on <a href="file:///Users/philip/src/blog/content/blog/language-servers/foo/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts#L248%2C13"><code>searchValue</code></a>. This method is expected to implement its own replacement algorithm.</p>
<p><em>@param</em> <code>searchValue</code> — An object that supports searching for and replacing matches within a string.  </p>
<p><em>@param</em> <code>replaceValue</code> — The replacement text.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return /%/.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">value) ?<span class="annotation"><p><code>(parameter) value: string</code></p></span></span><span class="annotated"> </span><span class="annotated">decodeURIComponent_<span class="annotation"><p><code>const decodeURIComponent_: (encodedURIComponent: string) =&gt; string</code>
Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).</p>
<p><em>@param</em> <code>encodedURIComponent</code> — A value representing an encoded URI component.</p></span></span><span class="annotated">(</span><span class="annotated">value) :<span class="annotation"><p><code>(parameter) value: string</code></p></span></span><span class="annotated"> </span><span class="annotated">value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">const </span><span class="annotated">_getQueryParam = (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const _getQueryParam: (url: string, key?: string, multiple?: boolean) =&gt; string | undefined | Record&lt;string, string&gt; | string[] | Record&lt;string, string[]&gt;</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">url: string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">key?: string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">multiple?: boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) multiple: boolean | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">): string | undefined | </span><span class="annotated">Record<string, string> | string[] |<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span><span class="annotated"> </span><span class="annotated">Record<string, string[]> => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">encoded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let encoded: any</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  if (!</span><span class="annotated">multiple &&<span class="annotation"><p><code>(parameter) multiple: boolean | undefined</code></p></span></span><span class="annotated"> </span><span class="annotated">key && !/[%+]/<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span><span class="annotated">.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">key)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    // optimized for unencoded key</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    let </span><span class="annotated">keyIndex =<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf(`?$<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated">{</span><span class="annotated">key}`, 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">keyIndex === -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">keyIndex =<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf(`&$<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated">{</span><span class="annotated">key}`, 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    while (</span><span class="annotated">keyIndex !== -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      const </span><span class="annotated">trailingKeyCode =<span class="annotation"><p><code>const trailingKeyCode: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">charCodeAt<span class="annotation"><p><code>(method) String.charCodeAt(index: number): number</code>
Returns the Unicode value of the character at the specified location.</p>
<p><em>@param</em> <code>index</code> — The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.</p></span></span><span class="annotated">(</span><span class="annotated">keyIndex +<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">key<span class="annotation"><p><code>(parameter) key: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length + 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (</span><span class="annotated">trailingKeyCode === 61) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const trailingKeyCode: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        const </span><span class="annotated">valueIndex =<span class="annotation"><p><code>const valueIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">keyIndex +<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">key<span class="annotation"><p><code>(parameter) key: string</code></p></span></span><span class="annotated">.</span><span class="annotated">length + 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(property) String.length: number</code>
Returns the length of a String object.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        const </span><span class="annotated">endIndex =<span class="annotation"><p><code>const endIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('&',<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated"> </span><span class="annotated">valueIndex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const valueIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        return </span><span class="annotated">_decodeURI<span class="annotation"><p><code>const _decodeURI: (value: string) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated">(</span><span class="annotated">valueIndex,<span class="annotation"><p><code>const valueIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">endIndex === -1 ? undefined :<span class="annotation"><p><code>const endIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">endIndex))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const endIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      } else if (</span><span class="annotated">trailingKeyCode == 38 ||<span class="annotation"><p><code>const trailingKeyCode: number</code></p></span></span><span class="annotated"> </span><span class="annotated">isNaN<span class="annotation"><p><code>function isNaN(number: number): boolean</code>
Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).</p>
<p><em>@param</em> <code>number</code> — A numeric value.</p></span></span><span class="annotated">(</span><span class="annotated">trailingKeyCode)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const trailingKeyCode: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        return ''</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">keyIndex =<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf(`&$<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated">{</span><span class="annotated">key}`,<span class="annotation"><p><code>(parameter) key: string</code></p></span></span><span class="annotated"> </span><span class="annotated">keyIndex + 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    </span><span class="annotated">encoded = /[%+]/<span class="annotation"><p><code>let encoded: any</code></p></span></span><span class="annotated">.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">url)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (!</span><span class="annotated">encoded) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let encoded: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      return undefined</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    // fallback to default routine</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  const </span><span class="annotated">results:<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated"> </span><span class="annotated">Record<string, string> |<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span><span class="annotated"> </span><span class="annotated">Record<string, string[]> = {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">encoded ??= /[%+]/<span class="annotation"><p><code>let encoded: any</code></p></span></span><span class="annotated">.</span><span class="annotated">test<span class="annotation"><p><code>(method) RegExp.test(string: string): boolean</code>
Returns a Boolean value that indicates whether or not a pattern exists in a searched string.</p>
<p><em>@param</em> <code>string</code> — String on which to perform the search.</p></span></span><span class="annotated">(</span><span class="annotated">url)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  let </span><span class="annotated">keyIndex =<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('?', 8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  while (</span><span class="annotated">keyIndex !== -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    const </span><span class="annotated">nextKeyIndex =<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('&',<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated"> </span><span class="annotated">keyIndex + 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    let </span><span class="annotated">valueIndex =<span class="annotation"><p><code>let valueIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">indexOf('=',<span class="annotation"><p><code>(method) String.indexOf(searchString: string, position?: number): number</code>
Returns the position of the first occurrence of a substring.</p>
<p><em>@param</em> <code>searchString</code> — The substring to search for in the string  </p>
<p><em>@param</em> <code>position</code> — The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.</p></span></span><span class="annotated"> </span><span class="annotated">keyIndex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">valueIndex ><span class="annotation"><p><code>let valueIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex &&<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex !== -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">valueIndex = -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let valueIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    let </span><span class="annotated">name =<span class="annotation"><p><code>let name: string</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">keyIndex + 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let keyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">valueIndex === -1 ? <span class="annotation"><p><code>let valueIndex: number</code></p></span></span><span class="annotated">(</span><span class="annotated">nextKeyIndex === -1 ? undefined :<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex) :<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">valueIndex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let valueIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    )</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">encoded) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let encoded: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">name =<span class="annotation"><p><code>let name: string</code></p></span></span><span class="annotated"> </span><span class="annotated">_decodeURI<span class="annotation"><p><code>const _decodeURI: (value: string) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let name: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    </span><span class="annotated">keyIndex =<span class="annotation"><p><code>let keyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">name === '') {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let name: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      continue</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    let </span><span class="annotated">value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let value: any</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">valueIndex === -1) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let valueIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">value = ''&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let value: any</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    } else {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">value =<span class="annotation"><p><code>let value: any</code></p></span></span><span class="annotated"> </span><span class="annotated">url<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated">.</span><span class="annotated">slice<span class="annotation"><p><code>(method) String.slice(start?: number, end?: number): string</code>
Returns a section of a string.</p>
<p><em>@param</em> <code>start</code> — The index to the beginning of the specified portion of stringObj.  </p>
<p><em>@param</em> <code>end</code><br />
The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.
If this value is not specified, the substring continues to the end of stringObj.</p></span></span><span class="annotated">(</span><span class="annotated">valueIndex + 1,<span class="annotation"><p><code>let valueIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex === -1 ? undefined :<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span><span class="annotated"> </span><span class="annotated">nextKeyIndex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const nextKeyIndex: number</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (</span><span class="annotated">encoded) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let encoded: boolean</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">value =<span class="annotation"><p><code>let value: any</code></p></span></span><span class="annotated"> </span><span class="annotated">_decodeURI<span class="annotation"><p><code>const _decodeURI: (value: string) =&gt; string</code></p></span></span><span class="annotated">(</span><span class="annotated">value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    if (</span><span class="annotated">multiple) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) multiple: boolean | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      if (!(</span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">name] &&<span class="annotation"><p><code>let name: string</code></p></span></span><span class="annotated"> </span><span class="annotated">Array<span class="annotation"><p><code>var Array: ArrayConstructor</code></p></span></span><span class="annotated">.</span><span class="annotated">isArray<span class="annotation"><p><code>(method) ArrayConstructor.isArray(arg: any): arg is any[]</code></p></span></span><span class="annotated">(</span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">name]))) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let name: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">        </span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">name] = []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let name: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      ;(</span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">name] as string[])<span class="annotation"><p><code>let name: string</code></p></span></span><span class="annotated">.</span><span class="annotated">push<span class="annotation"><p><code>(method) Array&lt;string&gt;.push(...items: string[]): number</code>
Appends new elements to the end of an array, and returns the new length of the array.</p>
<p><em>@param</em> <code>items</code> — New elements to add to the array.</p></span></span><span class="annotated">(</span><span class="annotated">value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    } else {</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">      </span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">name] ??=<span class="annotation"><p><code>let name: string</code></p></span></span><span class="annotated"> </span><span class="annotated">value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>let value: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">    }</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  }</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">key ?<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span><span class="annotated"> </span><span class="annotated">results<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">[</span><span class="annotated">key] :<span class="annotation"><p><code>(parameter) key: string</code></p></span></span><span class="annotated"> </span><span class="annotated">results&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const results: Record&lt;string, string&gt; | Record&lt;string, string[]&gt;</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getQueryParam: (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const getQueryParam: (url: string, key?: string) =&gt; string | undefined | Record&lt;string, string&gt;</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">url: string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">key?: string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">) => string | undefined | </span><span class="annotated">Record<string, string> =<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span><span class="annotated"> </span><span class="annotated">_getQueryParam as (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const _getQueryParam: (url: string, key?: string, multiple?: boolean) =&gt; string | undefined | Record&lt;string, string&gt; | string[] | Record&lt;string, string[]&gt;</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">url: string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">key?: string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">) => string | undefined | </span><span class="annotated">Record<string, string>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">getQueryParams = (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>const getQueryParams: (url: string, key?: string) =&gt; string[] | undefined | Record&lt;string, string[]&gt;</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">url: string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) url: string</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  </span><span class="annotated">key?: string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">): string[] | undefined | </span><span class="annotated">Record<string, string[]> => {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">  return </span><span class="annotated">_getQueryParam<span class="annotation"><p><code>const _getQueryParam: (url: string, key?: string, multiple?: boolean) =&gt; string | undefined | Record&lt;string, string&gt; | string[] | Record&lt;string, string[]&gt;</code></p></span></span><span class="annotated">(</span><span class="annotated">url,<span class="annotation"><p><code>(parameter) url: string</code></p></span></span><span class="annotated"> </span><span class="annotated">key, true) as string[] | undefined |<span class="annotation"><p><code>(parameter) key: string | undefined</code></p></span></span><span class="annotated"> </span><span class="annotated">Record<string, string[]>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }</code>
Construct a type with a set of properties K of type T</p></span></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">}</span></span>
                <span class="line"><span class="linen"></span></span>
                <span class="line"><span class="linen"></span><span class="annotated">// `decodeURIComponent` is a long name.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">// By making it a function, we can use it commonly when minified, reducing the amount of code.</span></span>
                <span class="line"><span class="linen"></span><span class="annotated">export const </span><span class="annotated">decodeURIComponent_ =<span class="annotation"><p><code>const decodeURIComponent_: (encodedURIComponent: string) =&gt; string</code></p></span></span><span class="annotated"> </span><span class="annotated">decodeURIComponent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation"><p><code>function decodeURIComponent(encodedURIComponent: string): string</code>
Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).</p>
<p><em>@param</em> <code>encodedURIComponent</code> — A value representing an encoded URI component.</p></span></span></span>
            </pre>
            </div>
            </details>
        
    </body>
    </html>
    